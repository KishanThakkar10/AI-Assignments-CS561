# -*- coding: utf-8 -*-
"""CS561_AI_Assignment_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NMdgwylJoR1R7HSEZWE7BzqW1j6kHm2Y

#**CS561 - Assignment 2 : Robot Localization Using HMMs**

##**Group Members**
###Jash Ratanghayra : 234101019
###Kishan Hitendra Thakkar : 234101024
"""

import numpy as np
import matplotlib.pyplot as pl
#import matplotlib.pyplot as pa

#Defining the height and width of the grid
X=4;Y=16
grid=np.ones([4,16])

#Defining the transition matrix
T=np.zeros([43,43],)

#Defining empty locations in the grid
empty_sq=[]

#Defining the emission matrix
O=np.zeros([43,43])

#Finding empty squares in the grid
def initialize_empty_squares():
    for x in range(0,4):
        for y in range(0,16):
            if(grid[x][y]==1):
                empty_sq.append((x,y))

#Calculating the  transition model
def transition_model():
    for i in range(0,43):
        (x ,y)=empty_sq[i]
        Neigh=Neighbour(x,y)
        Ns=len(Neigh)
        for j in range(0,Ns):
            index=empty_sq.index(Neigh[j])
            T[i][index]=1/Ns

#calculating sensor model at time t
#(x,y) is true location of the robot at time t
def sensor_model(x,y,epsilon):
    R=sensor_reading(x,y)
    for i in range(0,43):
        (a,b)=empty_sq[i]
        A=sensor_reading(a,b)
        dit=error(A,R)
        t=np.power(1-epsilon,4-dit)*np.power(epsilon,dit)
        O[i][i]=t;

#Find all possible neighbour of a current location
def Neighbour(x,y):
    a_list=[]
    if x-1>=0 and grid[x-1][y]==1:
        a_list.append((x-1,y))
    if x+1<X and grid[x+1][y]==1:
        a_list.append((x+1,y))
    if y+1<Y and grid[x][y+1]==1:
        a_list.append((x,y+1))
    if y-1>=0 and grid[x][y-1]==1:
        a_list.append((x,y-1))
    return a_list

#Find sensor reading at a given location
def sensor_reading(x,y):
    reading=list("1111")
    if x-1<0 or grid[x-1][y]==0:
        reading[0]="0"
    if x+1>=X or grid[x+1][y]==0:
        reading[1]="0"
    if y+1>=Y or grid[x][y+1]==0:
        reading[2]="0"
    if y-1<0 or grid[x][y-1]==0:
        reading[3]="0"
    return reading

#Error is defined as the discrepancy between true value of a square and the sensor reading
def error(A,R):
    cnt=0;
    for i in range(0,4):
        if A[i]!= R[i]:
            cnt=cnt+1
    return cnt

#Filtering or the forward procedure
def filtering(f):
    f=np.matmul(O,np.matmul(np.transpose(T),f))
    return f

#Creating the grid
def initialize_grid():
    grid[0][4]=0;grid[0][10]=0;grid[0][14]=0;grid[1][0]=0
    grid[1][1]=0;grid[1][4]=0;grid[1][6]=0;grid[1][7]=0
    grid[1][9]=0;grid[1][11]=0;grid[1][13]=0;grid[1][14]=0
    grid[1][15]=0;grid[2][0]=0;grid[2][4]=0;grid[2][6]=0
    grid[2][13]=0;grid[2][14]=0;grid[3][2]=0
    grid[3][6]=0;grid[3][11]=0

#Implementing the HMMs
def Hidden_Markov_Model():
    sigma_val=[0.0,0.02,0.05,0.1,0.2]
    _run=400
    _localization_error=[]
    _path_acuracy=[]
    for _error in range(0,len(sigma_val)):
        epsilon=sigma_val[_error]
        avg_arr_err=[]
        avg_arr_acc=[]
        best_path = []
        for iter in range(0,_run):
            f=np.full([43,1],1/43) #prior
            m=np.full([43,1],1/43)
            arr_err=[]
            arr_acc=[]
            e_path=[]
            a_path=[]
            while(True):
                ind=np.random.randint(0,43, size=None)
                (a,b)=empty_sq[ind]
                N=Neighbour(a,b)
                if(len(N)!=0):
                    break;
            start=1
            for i in range(0,43):
                if start!=1:
                    N=Neighbour(a,b)
                    Nind=np.random.randint(0,len(N), size=None)
                    (a,b)=N[Nind]
                sensor_model(a,b,epsilon)   # calculate O matrix
                f=filtering(f)              #find posterior
                ind=np.argmax(f)
                #print("ind="+str(ind))
                x,y=empty_sq[ind]
                arr_err.append(abs(a-x)+abs(b-y));
                m,z=viterbi_algo(m)
                e_path.append(empty_sq[z])
                a_path.append((a,b))
                #print(e_path)
                acc=path_acc(e_path,a_path)
                arr_acc.append(acc)
                start=0;
            best_path = e_path
            avg_arr_err.append(arr_err)
            avg_arr_acc.append(arr_acc)

        cal_avg_err=[]
        cal_avg_acc=[]
        for i in range(0,43):
            cal_avg_err.append(0)
            cal_avg_acc.append(0)
        for i in range(0,_run):
            for j in range(0,43):
                cal_avg_err[j]=cal_avg_err[j]+avg_arr_err[i][j]
                cal_avg_acc[j]=cal_avg_acc[j]+avg_arr_acc[i][j]
        for i in range(0,43):
            cal_avg_err[i]=cal_avg_err[i]/_run
            cal_avg_acc[i]=cal_avg_acc[i]/_run

        _localization_error.append(cal_avg_err)
        _path_acuracy.append(cal_avg_acc)


        print("\n")
        print("Epsilon = ", epsilon)
        print("Length of best path = ", len(best_path))
        print("Path = ",best_path)

    plt.figure(figsize=(8, 5))
    pl.title('Error')
    pl.xlabel('Number of Observations')
    pl.ylabel('Localization error')
    for i in range(0,len(sigma_val)):
        pl.plot(_localization_error[i],label=sigma_val[i])
    pl.legend()
    print("\nLocalization Error Plot\n")
    pl.show()

    plt.figure(figsize=(8, 5))
    pl.title('Accuracy')
    pl.xlabel('Number of Observations')
    pl.ylabel('Path Accuracy')
    for i in range(0,len(sigma_val)):
        pl.plot(_path_acuracy[i],label=sigma_val[i])
    pl.legend()
    print("\n\nPath Accuracy Plot\n")
    pl.show()

#Finding the path accuracy
def path_acc(e_path,a_path):
    cnt=0;
    for i in range(0,len(e_path)):
         if e_path[i]==a_path[i]:
             cnt=cnt+1;
    return cnt/len(e_path)

#implementing the viterbi algorithm for the most likely path
def viterbi_algo(m):
    g=np.multiply(np.transpose(T),np.transpose(m))
    #print(np.transpose(T))
    #print(np.transpose(m))
    t=np.amax(g,axis=1)
    #print(t)
    m=np.matmul(O,t)
    max_ind=np.argmax(m)
    return m,max_ind

#The main function
if __name__ == '__main__':
    initialize_grid()
    initialize_empty_squares()
    transition_model()
    TT=np.transpose(T)
    Hidden_Markov_Model()

